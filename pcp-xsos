#!/bin/bash
# 
# Copyright (c) 2024 Red Hat.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# Pretty-print sosreport information using Performance Co-Pilot metrics
# from local host or an archive.
#

. $PCP_DIR/etc/pcp.env

sts=2
awk="$PCP_AWK_PROG"
tmp=`mktemp -d "$PCP_TMPFILE_DIR/pcp-xsos.XXXXXXXXX"` || exit 1
trap "rm -rf $tmp; exit \$sts" 0 1 2 3 15

progname=`basename $0`

mem_metrics=(
    mem.physmem mem.util.used mem.util.dirty
    mem.util.shmem mem.util.bufmem mem.util.cached
    mem.util.swapFree mem.util.swapTotal
    mem.util.slab mem.util.pageTables
    mem.util.lowFree mem.util.lowTotal
    mem.util.anonhugepages
    mem.util.hugepagesFreeBytes mem.util.hugepagesTotalBytes
    mem.vmmemctl.current mem.vmmemctl.target
)

os_metrics=(
    hinv.ncpu hinv.pagesize
    pmcd.hostname pmcd.timezone pmcd.zoneinfo
    kernel.uname.release kernel.uname.version
    kernel.uname.sysname kernel.uname.machine
    kernel.uname.nodename kernel.uname.distro
    kernel.all.boottime kernel.all.uptime
    kernel.all.nusers kernel.all.load kernel.all.hz
    kernel.all.runnable kernel.all.running
    kernel.all.blocked kernel.all.nprocs
    kernel.all.cpu.user kernel.all.cpu.nice
    kernel.all.cpu.sys kernel.all.cpu.idle
    kernel.all.cpu.wait.total kernel.all.cpu.steal
    kernel.all.cpu.irq.soft kernel.all.cpu.irq.hard
)

_usage()
{
    [ ! -z "$@" ] && echo $@ 1>&2
    pmgetopt --progname=$progname --usage --config=$tmp/usage
    exit 1
}

# usage spec for pmgetopt, note posix flag (commands mean no reordering)
cat > $tmp/usage << EOF
# getopts: a:h:O:?omu:x
   --archive
   --host
   --origin
   --help
   --all           show everything
   -o,--os         show hostname, distro, kernel info, uptime, etc
   -m,--mem        display memory summary
   -u=P, --units=P change byte display where P is "b" for byte, "k", "m", "g", or "t"
   -x,--nocolor    disable output colorization
# end
EOF

color=true
osflag=false
memflag=false
units='G' # options: B (byte), K, M, G or T
batch=''
args=`pmgetopt --progname=$progname --config=$tmp/usage -- "$@"`
[ $? != 0 ] && exit 1

eval set -- "$args"
while [ $# -gt 0 ]
do
    case "$1" in
      # pcp options
      -a)
        export PCP_ARCHIVE="$2"
        batch="-b 1"
        shift
        ;;
      -h)
        export PCP_HOST="$2"
        shift
        ;;
      -O)
        export PCP_ORIGIN="$2"
        shift
        ;;
      # pcp-xsos options
      --all)
        osflag=true
        memflag=true
        ;;
      -m)
        memflag=true
        ;;
      -o)
        osflag=true
        ;;
      -u)
        units=`echo "$2" | tr '[:lower:]' '[:upper:]' | cut -c 1`
        ;;
      -x)
        color=false
        ;;
      -\?)
        _usage ""
        ;;
      --)        # end of options, start of arguments
        shift
        break
        ;;
    esac
    shift        # finished with this option, move to next
done

# set bytes precision (percent, bytes-low, bytes-high) based on units;
# also stash the display string for each unit and divisor (from KiB).
if test "$units" = "T"; then
    precision=(0 2 3)
    units=(TiB 1073741824)
elif test "$units" = "G"; then
    precision=(0 1 2)
    units=(GiB 1048576)
elif test "$units" = "M"; then
    precision=(1 0 0)
    units=(MiB 1024)
elif test "$units" = "K"; then
    precision=(1 0 0)
    units=(KiB 1)
else # bytes
    precision=(1 0 0)
    units=(B 1/1024)
fi

# accumulate an array of all metrics to be fetched
metrics=()
$osflag && metrics+=( ${os_metrics[*]} )
$memflag && metrics+=( ${mem_metrics[*]} )

# default to OS metrics if nothing specified
if test ${#metrics[@]} -eq 0; then
    metrics=( ${os_metrics[*]} )
    osflag=true
fi

if [ ! -z "$PCP_ARCHIVE" ]
then
    # extract pmcd values from log label in case metrics missing
    eval `pmdumplog -Ll 2>/dev/null | $awk '
/^Performance metrics from host/ { printf "pmcd_hostname_value=\"%s\"\n", $5 }
/^Archive timezone: /            { printf "pmcd_timezone_value=\"%s\"\n", $3 }
/^Archive zoneinfo: /            { printf "pmcd_zoneinfo_value=\"%s\"\n", $3 }
'`
fi

# Extract values for all metrics at once.  Fetch using pminfo then
# cater for 3 cases: single-valued metrics, set-valued metrics and
# errors fetching individual metrics (see pminfo example below).
# It translates the pminfo output into a series of bash variables,
# including arrays (for set-valued metrics inst names and values).
#
# Input:
# pminfo -f kernel.all.pswitch kernel.all.load kernel.cpu.util.user
#
# kernel.all.pswitch
#    value 730564942
#
# kernel.all.load
#    inst [1 or "1 minute"] value 0.02
#    inst [5 or "5 minute"] value 0.05
#    inst [15 or "15 minute"] value 0
#
# kernel.cpu.util.user
# No value(s) available!

# Output:
# kernel_all_pswitch_value=730564942
# kernel_all_load_inst[1]="1 minute"
# kernel_all_load_value[1]=0.19
# kernel_all_load_inst[5]="5 minute"
# kernel_all_load_value[5]=0.12
# kernel_all_load_inst[15]="15 minute"
# kernel_all_load_value[15]=0.06
# kernel_cpu_util_user_error="No value(s) available!"

if ! pminfo $batch --fetch ${metrics[*]} > $tmp/metrics 2>$tmp/error
then
    if grep "^pminfo:" $tmp/error > /dev/null 2>&1
    then
        $PCP_ECHO_PROG $PCP_ECHO_N "$progname: ""$PCP_ECHO_C"
        sed < $tmp/error -e 's/^pminfo: //g'
        sts=1
        exit
    fi
fi
[ -s $tmp/error ] && sed -e '/Unknown metric name/d' <$tmp/error >&2

$awk < $tmp/metrics > $tmp/variables '
BEGIN { error = 0; count = 0; value = 0; metric = "" }
{
    if (NF == 0) {   # end previous metric (if any)
        metric = ""
    } else if (metric == "") {   # new metric, name
        gsub("\\.", "_", $1)
        metric = $1
        count++
    } else if ($1 == "value") {   # singleton metric
        printf("%s_value=%s\n", metric, substr($0,11))
        value++
    } else if ($1 == "inst") {   # set-valued metric
        sub("\\[", "")
        instid = $2
        instoff = index($0, " or \"") + 4
        instend = index($0, "\"]")
        instname = substr($0, instoff, instend-instoff+1)
        valuestr = substr($0, index($0, "] value ") + 8)
        printf("%s_inst[%s]=%s\n", metric, instid, instname)
        printf("%s_value[%s]=%s\n", metric, instid, valuestr)
        value++
    } else {    # set an error string for the metric
        printf("%s=%c%s%c\n", metric, "\"", $0, "\"")
        metric = ""
        error++
    }
}
END { printf "metrics=%d\nvalues=%d\nerrors=%d\n", count, value, error }'
eval `cat $tmp/variables`
#cat $tmp/variables

if $color; then
    RESET='\033[0m' # use defaults
    BLACK='\033[0;30m'
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    ORANGE='\033[0;33m'
    BLUE='\033[0;34m'
    PURPLE='\033[0;35m'
    CYAN='\033[0;36m'
    WHITE='\033[0;37m'
    BACKBLUE='\033[44m' # background in blue
    BOLDWHITE='\033[1;37m'
    BOLDPURPLE='\033[1;35m'
    BOLDBLUE='\033[1;34m'
    BOLDRED='\033[1;31m'
fi

H0="${BOLDRED}"  # heading color
H1="  ${BOLDPURPLE}"  # next level down
H2="    ${BOLDBLUE}"  # second level heading

put_value()
{
    # $1 - mandatory metric name, e.g. kernel.all.pswitch
    # $2 - optional fallback value, used to override error string
    eval __value=`echo ${1} | sed -e 's/^/$/' -e 's/\./_/g' -e 's/$/_value/'`
    eval __error=`echo ${1} | sed -e 's/^/$/' -e 's/\./_/g' -e 's/$/_error/'`

    test -n "${__value}" && printf "${__value}" && return 0
    test -n "${__error}" -a -z "${2}" && printf "${RED}(missing)" && return 3
    test -n "${2}" && printf "${ORANGE}${2}" && echo 2
    printf "${ORANGE}unknown"
    return 1
}

get_value()
{
    # $1 - mandatory metric name, e.g. kernel.all.pswitch
    # $2 - mandatory fallback value, used when missing metric value
    eval __value=`echo ${1} | sed -e 's/^/$/' -e 's/\./_/g' -e 's/$/_value/'`
    test -n "${__value}" && echo "${__value}" && return 0
    echo "${2}"
    return 1
}

get_inst_value()
{
    # $1 - mandatory metric name, e.g. kernel.all.pswitch
    # $2 - mandatory numeric instance identifier, e.g. 1
    eval __value=`echo ${1} | sed -e 's/^/${/' -e 's/\./_/g' -e 's/$/_value['$2']}/'`
    test -n "${__value}" && echo "${__value}" && return 0
    echo "unknown"
    return 1
}

print_uptime()
{
    # Report on system up-time in days, hours and minutes
    # and number of users (given booted seconds + nusers)
    seconds=`echo "$1" | sed -e 's/\..*$//g'`
    users="$2"

    days=$((seconds / (60 * 60 * 24)))
    minutes=$((seconds / 60))
    hours=$((minutes / 60))
    hours=$((hours % 24))
    minutes=$((minutes % 60))
    if test $days -gt 1; then
        printf "$days days,"
    elif test $days -ne 0; then
        printf "1 day,"
    fi
    if test $hours -ne 0; then
        printf ' %2d:%02d,' $hours $minutes
    else
        printf ' %d min,' $minutes
    fi
    if test $users -eq 1; then
        printf '   1 user\n'
    else
        printf ' %2d users\n' $users
    fi
}

pcp_xsos_os()
{
    printf "${H0}OS\n"

    printf "${H1}Hostname:${RESET} "
    put_value pmcd.hostname; echo
    printf "${H1}Distro:${RESET}   "
    banner=`put_value kernel.uname.distro`
    printf "${BACKBLUE}${banner}${RESET}\n"
    printf "${H1}Arch:${RESET}     "
    platform=`put_value kernel.uname.machine`
    printf "platform=$platform\n"
    printf "${H1}Kernel:${RESET}\n"
    printf "${H2}Hertz:${RESET}         "
    put_value kernel.all.hz; echo
    printf "${H2}Pagesize:${RESET}      "
    put_value hinv.pagesize; echo
    printf "${H2}Build version:${RESET}\n"
    release=`put_value kernel.uname.release`
    release="version $release"
    sysname=`put_value kernel.uname.sysname`
    sysname="$sysname $release"
    version=`put_value kernel.uname.version "unknown build version"`
    printf "      ${ORANGE}${sysname}${RESET}\n"
    printf "      ${ORANGE}${version}${RESET}\n"
    printf "    - - - - - - - - - - - - - - - - - - -\n"

    printf "${H1}Boot time: ${RESET}"
    boottime=`get_value kernel.all.boottime 0`
    date --date="@$boottime" +"%a %b %d %I:%M:%S %P %Z %Y"
    printf "${H1}Time Zone: ${RESET}"
    timezone=`get_value pmcd.timezone unknown`
    zoneinfo=`get_value pmcd.zoneinfo unknown | sed -e 's/^://'`
    printf "${zoneinfo} [${timezone}]\n"
    printf "${H1}Uptime: ${RESET}  "
    uptime=`get_value kernel.all.uptime 0`
    nusers=`get_value kernel.all.nusers 0`
    print_uptime $uptime $nusers
    printf "${H1}LoadAvg:${RESET}  "
    ncpus=`get_value hinv.ncpu 0`
    printf "${BOLDWHITE}[$ncpus CPU]${RESET}"
    test $ncpus -lt 1 && ncpus=1  # safe division later
    for inst in 1 5 15; do
        load=`get_inst_value kernel.all.load $inst`
        percent=`$awk "BEGIN {print int(${load}*${ncpus}+.5)}"`
        test $inst -eq 1 || printf ","
        printf " %.2f (${GREEN}%d%%${RESET})" $load $percent
        test $inst -eq 15 && printf "\n"
    done

    printf "${H1}Processes: ${RESET}\n"
    printf "${H2}running: ${RESET}"
    put_value kernel.all.running
    printf "${H2}runnable: ${RESET}"
    put_value kernel.all.runnable
    printf "${H2}blocked: ${RESET}"
    put_value kernel.all.blocked
    printf "${H2}count: ${RESET}"
    put_value kernel.all.nprocs; echo

    printf "${H1}Processors: ${RESET}\n"
    printf "${H2}cpu [Utilization since boot]: ${RESET}\n      "
    us=`get_value kernel.all.cpu.user 0`
    ni=`get_value kernel.all.cpu.nice 0`
    sy=`get_value kernel.all.cpu.sys 0`
    id=`get_value kernel.all.cpu.idle 0`
    wt=`get_value kernel.all.cpu.wait.total 0`
    ih=`get_value kernel.all.cpu.irq.hard 0`
    is=`get_value kernel.all.cpu.irq.soft 0`
    st=`get_value kernel.all.cpu.steal 0`
    $awk "BEGIN {
        tot=$us+$ni+$sy+$id+$wt+$ih+$is+$st;
        printf \"us %d%%, \", int($us/tot*100+.5)
        printf \"ni %d%%, \", int($ni/tot*100+.5)
        printf \"sys %d%%, \", int($sy/tot*100+.5)
        printf \"idle %d%%, \", int($id/tot*100+.5)
        printf \"iowait %d%%, \", int($wt/tot*100+.5)
        printf \"irq %d%%, \", int($ih/tot*100+.5)
        printf \"sftirq %d%%, \", int($is/tot*100+.5)
        printf \"steal %d%%\n\", int($st/tot*100+.5)
    }"

    echo # additional space for next session (with --all)
}

pcp_xsos_mem()
{
    total=`get_value mem.physmem 1`
    used=`get_value mem.util.used 0`
    buffer=`get_value mem.util.bufmem 0`
    cached=`get_value mem.util.cached 0`
    huge=`get_value mem.util.hugepagesTotalBytes 0`
    hugefree=`get_value mem.util.hugepagesFreeBytes 0`
    hugeanon=`get_value mem.util.anonhugepages 0`
    dirty=`get_value mem.util.dirty 0`
    slab=`get_value mem.util.slab 0`
    ptes=`get_value mem.util.pageTables 0`
    shmem=`get_value mem.util.shmem 0`
    lowfree=`get_value mem.util.lowFree 0`
    lowtotal=`get_value mem.util.lowTotal 0`
    swaptotal=`get_value mem.util.swapTotal 0`
    swapfree=`get_value mem.util.swapFree 0`
    vmtarget=`get_value mem.vmmemctl.target 0`
    vmcurrent=`get_value mem.vmmemctl.current 0`

    $awk "
function round(num, places) {
    places = 10 ^ places
    return int(num * places + .5) / places
}
function put_hbar(title, color, value, total) {
    width = 50
    ratio = value/total
    hbars = int(ratio * width + .5)
    printf \"    %s%-10s \", color, title
    for (i=1; i < hbars+1; i++)
        printf \"▊\"
    printf \"${RESET}\"
    for (i=hbars; i < width; i++)
        printf \".\"
    printf \" %s%5.1f%%${RESET}\n\", color, ratio * 100 + .005
}
BEGIN {
    printf \"${H0}MEMORY\n\"

    printf \"${H1}Stats graphed as percent of MemTotal:${RESET}\n\"
    put_hbar(\"MemUsed\", \"${GREEN}\", $used, $total)
    put_hbar(\"Buffers\", \"${PURPLE}\", $buffer, $total)
    put_hbar(\"Cached\", \"${BLUE}\", $cached, $total)
    put_hbar(\"HugePages\", \"${CYAN}\", $huge/1024, $total)
    put_hbar(\"Dirty\", \"${RED}\", $dirty, $total)

    printf \"${H1}RAM:${RESET}\n\"
    printf \"    ${BOLDWHITE}%s ${units[0]} total ram${CLEAR}\n\",
            round($total/(${units[1]}), ${precision[1]})
    printf \"    ${WHITE}%s ${units[0]} (%s%%) used\n\",
            round($used/(${units[1]}), ${precision[1]}),
            round(($used/$total)*100, ${precision[0]})
    printf \"    ${BOLDWHITE}%s ${units[0]} (%s%%) used excluding Buffers/Cached\n\",
            round(($used-$buffer-$cached)/(${units[1]}), ${precision[1]}),
	    round((($used-$buffer-$cached)/$total)*100, ${precision[0]})
    printf \"    ${WHITE}%s ${units[0]} (%s%%) dirty\n\",
            round($dirty/(${units[1]}), ${precision[2]}),
            round(($dirty/$total)*100, ${precision[0]})
    printf \"${H1}HugePages:${RESET}\n\"
    if ($huge == 0)
        printf \"    No ram pre-allocated to HugePages\n\"
    else {
        printf \"    %s ${units[0]} pre-allocated to HugePages (%s%% of total ram)\n\",
                round(($huge/1024)/(${units[1]}), ${precision[1]}),
                round((($huge/1024)/($total))*100, ${precision[0]})
        printf \"    %s ${units[0]} of HugePages (%s%%) in-use by applications\n\",
                round(($huge-$hugefree)/1024/(${units[1]}), ${precision[1]}),
                round((($huge-$hugefree)/($huge))*100, ${precision[0]})
    }

    printf \"${H1}TransparentHugePages:${RESET}\n\"
    if ($hugeanon == 0)
        printf \"    No ram allocated to THP\n\"
    else
        printf \"    %s ${units[0]} allocated to THP\n\",
                round($hugeanon/(${units[1]}), ${precision[2]})

    if ($lowtotal != 0)
        printf \"    %s ${units[0]} (%s%%) of LowMem in-use\n\",
                round(($lowtotal-$lowfree)/(${units[1]}), ${precision[1]}),
		round((($lowtotal-$lowfree)/($lowtotal))*100, ${precision[0]})
    printf \"    %s ${units[0]} (%s%%) of total ram used for Slab\n\",
           round($slab/(${units[1]}), ${precision[2]}),
           round(($slab/$total)*100, ${precision[0]})
    printf \"    %s ${units[0]} (%s%%) of total ram used for PageTables\n\",
           round($ptes/(${units[1]}), ${precision[2]}),
           round(($ptes/$total)*100, ${precision[0]})
    printf \"    %s ${units[0]} (%s%%) of total ram used for Shmem\n\",
           round($shmem/(${units[1]}), ${precision[2]}),
           round(($shmem/$total)*100, ${precision[0]})

    printf \"${H1}Virtual Machine Balloon:${RESET}\n\"
    if ($vmtarget == 0)
        printf \"    No VM balloon memory target\n\"
    else
        printf \"    %s ${units[0]} (%s%%) of %s ${units[0]} balloon in-use\n\",
                round(($vmcurrent/1024)/(${units[1]}), ${precision[1]}),
		round(($vmcurrent/($vmtarget))*100, ${precision[0]}),
                round(($vmtarget/1024)/(${units[1]}), ${precision[1]})

    printf \"${H1}Swap:${RESET}\n\"
    if ($swaptotal == 0)
        printf \"    ${ORANGE}No system swap space configured${RESET}\n\"
    else
        printf \"    %s ${units[0]} (%s%%) used of %s ${units[0]} total\n\",
               round(($swaptotal-$swapfree)/(${units[1]}), ${precision[1]}),
	       round((($swapfree-$swaptotal)/$swaptotal)*100, ${precision[0]}),
               round($swaptotal/(${units[1]}), ${precision[1]})
}"

    echo # additional space for next session (with --all)
}

$osflag && pcp_xsos_os
$memflag && pcp_xsos_mem

sts=0
exit
