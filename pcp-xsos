#!/bin/bash
# 
# Copyright (c) 2024 Red Hat.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# Pretty-print sosreport information using Performance Co-Pilot metrics
# from local host or an archive.
#

. $PCP_DIR/etc/pcp.env

sts=2
awk="$PCP_AWK_PROG"
tmp=`mktemp -d "$PCP_TMPFILE_DIR/pcp-xsos.XXXXXXXXX"` || exit 1
trap "rm -rf $tmp; exit \$sts" 0 1 2 3 15

progname=`basename $0`

mem_metrics=(
    mem.physmem mem.util.used mem.util.dirty
    mem.util.shmem mem.util.bufmem mem.util.cached
    mem.util.swapFree mem.util.swapTotal
    mem.util.slab mem.util.pageTables
    mem.util.lowFree mem.util.lowTotal
    mem.util.anonhugepages
    mem.util.hugepagesFreeBytes mem.util.hugepagesTotalBytes
)

os_metrics=(
    hinv.ncpu hinv.pagesize
    pmcd.hostname pmcd.timezone pmcd.zoneinfo
    kernel.uname.release kernel.uname.version
    kernel.uname.sysname kernel.uname.machine
    kernel.uname.nodename kernel.uname.distro
    kernel.all.boottime kernel.all.uptime
    kernel.all.nusers kernel.all.load kernel.all.hz
    kernel.all.runnable kernel.all.running
    kernel.all.blocked kernel.all.nprocs
    kernel.all.cpu.user kernel.all.cpu.nice
    kernel.all.cpu.sys kernel.all.cpu.idle
    kernel.all.cpu.wait.total kernel.all.cpu.steal
    kernel.all.cpu.irq.soft kernel.all.cpu.irq.hard
)

_usage()
{
    [ ! -z "$@" ] && echo $@ 1>&2
    pmgetopt --progname=$progname --usage --config=$tmp/usage
    exit 1
}

# usage spec for pmgetopt, note posix flag (commands mean no reordering)
cat > $tmp/usage << EOF
# getopts: a:h:O:?omx
   --archive
   --host
   --origin
   --help
   --all           show everything
   -o,--os         show hostname, distro, kernel info, uptime, etc
   -m,--mem        display memory summary
   -x,--nocolor    disable output colorization
# end
EOF

color=true
osflag=false
memflag=false
batch=''
args=`pmgetopt --progname=$progname --config=$tmp/usage -- "$@"`
[ $? != 0 ] && exit 1

eval set -- "$args"
while [ $# -gt 0 ]
do
    case "$1" in
      # pcp options
      -a)
        export PCP_ARCHIVE="$2"
        batch="-b 1"
        shift
        ;;
      -h)
        export PCP_HOST="$2"
        shift
        ;;
      -O)
        export PCP_ORIGIN="$2"
        shift
        ;;
      # pcp-xsos options
      --all)
        osflag=true
        memflag=true
        ;;
      -m)
        memflag=true
        ;;
      -o)
        osflag=true
        ;;
      -x)
        color=false
        ;;
      -\?)
        _usage ""
        ;;
      --)        # end of options, start of arguments
        shift
        break
        ;;
    esac
    shift        # finished with this option, move to next
done

# accumulate an array of all metrics to be fetched
metrics=()
$osflag && metrics+=( ${os_metrics[*]} )
$memflag && metrics+=( ${mem_metrics[*]} )

# default to OS metrics if nothing specified
if test ${#metrics[@]} -eq 0; then
    metrics=( ${os_metrics[*]} )
    osflag=true
fi

if [ ! -z "$PCP_ARCHIVE" ]
then
    # extract pmcd values from log label in case metrics missing
    eval `pmdumplog -Ll 2>/dev/null | $awk '
/^Performance metrics from host/ { printf "pmcd_hostname_value=\"%s\"\n", $5 }
/^Archive timezone: /            { printf "pmcd_timezone_value=\"%s\"\n", $3 }
/^Archive zoneinfo: /            { printf "pmcd_zoneinfo_value=\"%s\"\n", $3 }
'`
fi

# Extract values for all metrics at once.  Fetch using pminfo then
# cater for 3 cases: single-valued metrics, set-valued metrics and
# errors fetching individual metrics (see pminfo example below).
# It translates the pminfo output into a series of bash variables,
# including arrays (for set-valued metrics inst names and values).
#
# Input:
# pminfo -f kernel.all.pswitch kernel.all.load kernel.cpu.util.user
#
# kernel.all.pswitch
#    value 730564942
#
# kernel.all.load
#    inst [1 or "1 minute"] value 0.02
#    inst [5 or "5 minute"] value 0.05
#    inst [15 or "15 minute"] value 0
#
# kernel.cpu.util.user
# No value(s) available!

# Output:
# kernel_all_pswitch_value=730564942
# kernel_all_load_inst[1]="1 minute"
# kernel_all_load_value[1]=0.19
# kernel_all_load_inst[5]="5 minute"
# kernel_all_load_value[5]=0.12
# kernel_all_load_inst[15]="15 minute"
# kernel_all_load_value[15]=0.06
# kernel_cpu_util_user_error="No value(s) available!"

if ! pminfo $batch --fetch ${metrics[*]} > $tmp/metrics 2>$tmp/error
then
    if grep "^pminfo:" $tmp/error > /dev/null 2>&1
    then
        $PCP_ECHO_PROG $PCP_ECHO_N "$progname: ""$PCP_ECHO_C"
        sed < $tmp/error -e 's/^pminfo: //g'
        sts=1
        exit
    fi
fi
[ -s $tmp/error ] && sed -e '/Unknown metric name/d' <$tmp/error >&2

$awk < $tmp/metrics > $tmp/variables '
BEGIN { error = 0; count = 0; value = 0; metric = "" }
{
    if (NF == 0) {   # end previous metric (if any)
        metric = ""
    } else if (metric == "") {   # new metric, name
        gsub("\\.", "_", $1)
        metric = $1
        count++
    } else if ($1 == "value") {   # singleton metric
        printf("%s_value=%s\n", metric, substr($0,11))
        value++
    } else if ($1 == "inst") {   # set-valued metric
        sub("\\[", "")
        instid = $2
        instoff = index($0, " or \"") + 4
        instend = index($0, "\"]")
        instname = substr($0, instoff, instend-instoff+1)
        valuestr = substr($0, index($0, "] value ") + 8)
        printf("%s_inst[%s]=%s\n", metric, instid, instname)
        printf("%s_value[%s]=%s\n", metric, instid, valuestr)
        value++
    } else {    # set an error string for the metric
        printf("%s=%c%s%c\n", metric, "\"", $0, "\"")
        metric = ""
        error++
    }
}
END { printf "metrics=%d\nvalues=%d\nerrors=%d\n", count, value, error }'
eval `cat $tmp/variables`
#cat $tmp/variables

if $color; then
    RESET='\033[0m' # use defaults
    BLACK='\033[0;30m'
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    ORANGE='\033[0;33m'
    BLUE='\033[0;34m'
    PURPLE='\033[0;35m'
    CYAN='\033[0;36m'
    WHITE='\033[0;37m'
    BACKBLUE='\033[44m' # background in blue
    BOLDWHITE='\033[1;37m'
    BOLDPURPLE='\033[1;35m'
    BOLDBLUE='\033[1;34m'
    BOLDRED='\033[1;31m'
fi

H0="${BOLDRED}"  # heading color
H1="  ${BOLDPURPLE}"  # next level down
H2="    ${BOLDBLUE}"  # second level heading

put_value()
{
    # $1 - mandatory metric name, e.g. kernel.all.pswitch
    # $2 - optional fallback value, used to override error string
    eval __value=`echo ${1} | sed -e 's/^/$/' -e 's/\./_/g' -e 's/$/_value/'`
    eval __error=`echo ${1} | sed -e 's/^/$/' -e 's/\./_/g' -e 's/$/_error/'`

    test -n "${__value}" && printf "${__value}" && return 0
    test -n "${__error}" -a -z "${2}" && printf "${RED}(missing)" && return 3
    test -n "${2}" && printf "${ORANGE}${2}" && echo 2
    printf "${ORANGE}unknown"
    return 1
}

get_value()
{
    # $1 - mandatory metric name, e.g. kernel.all.pswitch
    # $2 - mandatory fallback value, used when missing metric value
    eval __value=`echo ${1} | sed -e 's/^/$/' -e 's/\./_/g' -e 's/$/_value/'`
    test -n "${__value}" && echo "${__value}" && return 0
    echo "${2}"
    return 1
}

get_inst_value()
{
    # $1 - mandatory metric name, e.g. kernel.all.pswitch
    # $2 - mandatory numeric instance identifier, e.g. 1
    eval __value=`echo ${1} | sed -e 's/^/${/' -e 's/\./_/g' -e 's/$/_value['$2']}/'`
    test -n "${__value}" && echo "${__value}" && return 0
    echo "unknown"
    return 1
}

print_uptime()
{
    # Report on system up-time in days, hours and minutes
    # and number of users (given booted seconds + nusers)
    seconds=`echo "$1" | sed -e 's/\..*$//g'`
    users="$2"

    days=$((seconds / (60 * 60 * 24)))
    minutes=$((seconds / 60))
    hours=$((minutes / 60))
    hours=$((hours % 24))
    minutes=$((minutes % 60))
    if test $days -gt 1; then
        printf "$days days,"
    elif test $days -ne 0; then
        printf "1 day,"
    fi
    if test $hours -ne 0; then
        printf ' %2d:%02d,' $hours $minutes
    else
        printf ' %d min,' $minutes
    fi
    if test $users -eq 1; then
        printf '   1 user\n'
    else
        printf ' %2d users\n' $users
    fi
}

pcp_xsos_os()
{
    printf "${H0}OS\n"

    printf "${H1}Hostname:${RESET} "
    put_value pmcd.hostname; echo
    printf "${H1}Distro:${RESET}   "
    banner=`put_value kernel.uname.distro`
    printf "${BACKBLUE}${banner}${RESET}\n"
    printf "${H1}Arch:${RESET}     "
    platform=`put_value kernel.uname.machine`
    printf "platform=$platform\n"
    printf "${H1}Kernel:${RESET}\n"
    printf "${H2}Hertz:${RESET}         "
    put_value kernel.all.hz; echo
    printf "${H2}Pagesize:${RESET}      "
    put_value hinv.pagesize; echo
    printf "${H2}Build version:${RESET}\n"
    release=`put_value kernel.uname.release`
    release="version $release"
    sysname=`put_value kernel.uname.sysname`
    sysname="$sysname $release"
    version=`put_value kernel.uname.version "unknown build version"`
    printf "      ${ORANGE}${sysname}${RESET}\n"
    printf "      ${ORANGE}${version}${RESET}\n"
    printf "    - - - - - - - - - - - - - - - - - - -\n"

    printf "${H1}Boot time: ${RESET}"
    boottime=`get_value kernel.all.boottime 0`
    date --date="@$boottime" +"%a %b %d %I:%M:%S %P %Z %Y"
    printf "${H1}Time Zone: ${RESET}"
    timezone=`get_value pmcd.timezone unknown`
    zoneinfo=`get_value pmcd.zoneinfo unknown | sed -e 's/^://'`
    printf "${zoneinfo} [${timezone}]\n"
    printf "${H1}Uptime: ${RESET}  "
    uptime=`get_value kernel.all.uptime 0`
    nusers=`get_value kernel.all.nusers 0`
    print_uptime $uptime $nusers
    printf "${H1}LoadAvg:${RESET}  "
    ncpus=`get_value hinv.ncpu 0`
    printf "${BOLDWHITE}[$ncpus CPU]${RESET}"
    test $ncpus -lt 1 && ncpus=1  # safe division later
    for inst in 1 5 15; do
        load=`get_inst_value kernel.all.load $inst`
        percent=`$awk "BEGIN {print int(${load}*${ncpus}+.5)}"`
        test $inst -eq 1 || printf ","
        printf " %.2f (${GREEN}%d%%${RESET})" $load $percent
        test $inst -eq 15 && printf "\n"
    done

    printf "${H1}Processes: ${RESET}\n"
    printf "${H2}running: ${RESET}"
    put_value kernel.all.running
    printf "${H2}runnable: ${RESET}"
    put_value kernel.all.runnable
    printf "${H2}blocked: ${RESET}"
    put_value kernel.all.blocked
    printf "${H2}count: ${RESET}"
    put_value kernel.all.nprocs; echo

    printf "${H1}Processors: ${RESET}\n"
    printf "${H2}cpu [Utilization since boot]: ${RESET}\n      "
    us=`get_value kernel.all.cpu.user 0`
    ni=`get_value kernel.all.cpu.nice 0`
    sy=`get_value kernel.all.cpu.sys 0`
    id=`get_value kernel.all.cpu.idle 0`
    wt=`get_value kernel.all.cpu.wait.total 0`
    ih=`get_value kernel.all.cpu.irq.hard 0`
    is=`get_value kernel.all.cpu.irq.soft 0`
    st=`get_value kernel.all.cpu.steal 0`
    tot=`$awk "BEGIN {print $us+$ni+$sy+$id+$wt+$ih+$is+$st}"`
    printf "us %d%%, " `$awk "BEGIN {print int($us/$tot*100+.5)}"`
    printf "ni %d%%, " `$awk "BEGIN {print int($ni/$tot*100+.5)}"`
    printf "sys %d%%, " `$awk "BEGIN {print int($sy/$tot*100+.5)}"`
    printf "idle %d%%, " `$awk "BEGIN {print int($id/$tot*100+.5)}"`
    printf "iowait %d%%, " `$awk "BEGIN {print int($wt/$tot*100+.5)}"`
    printf "irq %d%%, " `$awk "BEGIN {print int($ih/$tot*100+.5)}"`
    printf "sftirq %d%%, " `$awk "BEGIN {print int($is/$tot*100+.5)}"`
    printf "steal %d%%\n" `$awk "BEGIN {print int($st/$tot*100+.5)}"`

    echo # additional space for next session (with --all)
}

put_hbar()
{
    # inputs: title color value total
    width=50
    ratio=`$awk "BEGIN {print $3/$4}"`
    hbars=`$awk "BEGIN {print int($ratio*$width+.5)}"`
    printf "    ${2}%-10s " $1
    for i in $(seq 1 $hbars); do printf "▊"; done
    printf "${RESET}"
    for i in $(seq $hbars $width); do printf "."; done
    printf " ${2}%5.1f%%${RESET}\n" `$awk "BEGIN {print $ratio*100+.005}"`
}

pcp_xsos_mem()
{
    printf "${H0}MEMORY\n"

    total=`get_value mem.physmem 1`
    used=`get_value mem.util.used 0`
    buffer=`get_value mem.util.bufmem 0`
    cached=`get_value mem.util.cached 0`
    huge=`get_value mem.util.hugepagesTotalBytes 0`
    hugefree=`get_value mem.util.hugepagesFreeBytes 0`
    hugeanon=`get_value mem.util.anonhugepages 0`
    dirty=`get_value mem.util.dirty 0`
    slab=`get_value mem.util.slab 0`
    ptes=`get_value mem.util.pageTables 0`
    shmem=`get_value mem.util.shmem 0`
    lowfree=`get_value mem.util.lowFree 0`
    lowtotal=`get_value mem.util.lowTotal 0`
    swaptotal=`get_value mem.util.swapTotal 0`
    swapfree=`get_value mem.util.swapFree 0`

    printf "${H1}Stats graphed as percent of MemTotal:${RESET}\n"
    put_hbar MemUsed "${GREEN}" $used $total
    put_hbar Buffers "${PURPLE}" $buffer $total
    put_hbar Cached "${BLUE}" $cached $total
    put_hbar HugePages "${CYAN}" $huge $total
    put_hbar Dirty "${RED}" $dirty $total

    printf "${H1}RAM:${RESET}\n"
    printf "    ${BOLDWHITE}%.1f GiB total ram${CLEAR}\n"\
           `$awk "BEGIN {print $total/1024/1024}"`
    printf "    ${WHITE}%.1f GiB (%d%%) used\n"\
           `$awk "BEGIN {print $used/1024/1024;
                         print int(($used/$total)*100+.5)}"`
    printf "    ${BOLDWHITE}%.1f GiB (%d%%) used excluding Buffers/Cached\n"\
           `$awk "BEGIN {print ($used-$buffer-$cached)/1024/1024;
                         print int(($used-$buffer-$cached)/$total*100+.5)}"`
    printf "    ${WHITE}%.1f GiB (%d%%) dirty\n"\
           `$awk "BEGIN {print $dirty/1024/1024;
                         print int($dirty/$total*100+.5)}"`

    printf "${H1}HugePages:${RESET}\n"
    if test $huge -eq 0; then
        printf "    No ram pre-allocated to HugePages\n"
    else
        printf "    %.1f GiB pre-allocated to HugePages (%s%% of total ram)\n"\
           `$awk "BEGIN {print $huge/1024/1024;
                         print int(($huge/$total)*100+.5)}"`
        printf "    %.1f GiB of HugePages (%s%%) in-use by applications\n"\
           `$awk "BEGIN {print $huge/1024/1024;
                         print int(($huge-$hugefree/$total)*100+.5)}"`
    fi
    printf "${H1}TransparentHugePages:${RESET}\n"
    if test $hugeanon -eq 0; then
        printf "    No ram allocated to THP\n"
    else
        printf "    %.2f GiB allocated to THP\n", $hugeanon
    fi

    printf "${H1}LowMem/Slab/PageTables/Shmem:${RESET}\n"
    if test $lowtotal -ne 0; then
        printf "    %.2f GiB (%d%%) of LowMem in-use\n" \
           `$awk "BEGIN {print ($lowtotal-$lowfree)/1024/1024;
                         print int(($lowtotal-$lowfree)*100+.5)}"`
    fi
    printf "    %.2f GiB (%d%%) of total ram used for Slab\n" \
           `$awk "BEGIN {print $slab/1024/1024;
                         print int(($slab/$total)*100+.5)}"`
    printf "    %.2f GiB (%d%%) of total ram used for PageTables\n" \
           `$awk "BEGIN {print $ptes/1024/1024;
                         print int(($ptes/$total)*100+.5)}"`
    printf "    %.2f GiB (%d%%) of total ram used for Shmem\n" \
           `$awk "BEGIN {print $shmem/1024/1024;
                         print int(($shmem/$total)*100+.5)}"`

    printf "${H1}Swap:${RESET}\n"
    if test $swaptotal -eq 0; then
        printf "    ${ORANGE}No system swap space configured${RESET}\n"
    else
        printf "    %.1f GiB (%d%%) used of %.1f GiB total\n" \
           `$awk "BEGIN {print ($swaptotal-$swapfree)/1024/1024}"` \
           `$awk "BEGIN {print int(($swapfree-$swaptotal)*100+.5)}"` \
           `$awk "BEGIN {print $swaptotal/1024/1024}"`
    fi

    echo # additional space for next session (with --all)
}

$osflag && pcp_xsos_os
$memflag && pcp_xsos_mem

sts=0
exit
